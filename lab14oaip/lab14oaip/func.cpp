#include <iostream>
#include "Header.h"
int HashFunction(int key, int size, int p)
// хэш-функция для расчёта позиции вставляемого или искомого Э-а
// int key - значение ключа, int size - максимальное к-во Э-в, int p - к-во коллизий
// функция используется при поиске и при вставке, а при удалении используется функция поиска, а следовательно, 

{
return ((int)(key % size + (key % size + 1) * p) % size);
}

// мой вариант 
//int Next_hash(int key, int size, int p)// p - счётчик колизий 
//{
//	return ((key % size + (key % size + 1) * p) % size);// расчёт хэш-функции по заданию
//}

//вариант 1

int Next_hash(int key, int size, int p)
{
	int c1 = 1; // Коэффициент c1 для квадратичной функции
	int c2 = 1; // Коэффициент c2 для квадратичной функции

	int hash = key % size;
	int i = p;
	int step = (c1 * i + c2 * i * i) % size;

	return (hash + step) % size;
}

//вариант 10

//int Next_hash(int key, int size, int p)
//{
//	int hash = key % size;
//	int step = p;
//
//	return (hash + step) % size;
//}

//вариант 15

//int Next_hash(int key, int size, int p)
//{
//	int h1 = (key % size);
//	int h2 = 1 + (key % size);
//	int hash = (h1 + p * h2) % size;
//
//	return hash;
//}

int universal(int key, int size, int p)	// обеспечивает равномерное хеширование: для очередного ключа вероятности помещения его в любую ячейку совпадают
{
	int h = 0, a = 314445, b = 37542;
	h = (a * h + key) % size;
	return (h < 0) ? (h + size) : h;
}


Object Create(int size, int(*getkey)(void*)) // функция создания хэш-таблицы 
 
	
{
return *(new Object(size, getkey));// создаём новую хэш-таблиццу и возвращаем её 
// new - создаёт таблицу и 

// * - получаем 

// size- размер хэш-
// getkey - функция для 

}

Object::Object(int size, int(*getkey)(void*))// конструктор хъш-таблиц
{
	N = 0;// задаём текущее число элементов, равное нулю
	// this - указатель на текущую структуру (т.е. хэш-таблицу)
	this->Size = size;// задаём указанный максимальный размер 
	this->GetKey = getkey;// запоминаем функцию для получения ключа из элемента
	this->Data = new void* [size];// выделение памяти под массив элементов 
	for (int i = 0; i < size; ++i)// устанавливаем все элементыв ноль для обозначения их пустоты
		Data[i] = NULL;
}

bool Object::Insert(void* d)// функция вставки элементов в хэш-таблицу
{

	int key = GetKey(d);

	if (SearchInd(key) != -1) {
		// Элемент с таким ключом уже существует
		return false;
	}

	bool b = false;

	if (N != Size) // если текущее количество не равно размеру хэш-таблиц (ещё есть свободные места)
	   // i - счётчик колизий, t - ключ вставляемого элемента, получаемый функцией 
		
		// j - позиция для вставки, расчитываем по хэш-функции HashFunction
		for (int i = 0, t = GetKey(d), j = HashFunction(t, Size, 0); i != Size * Size && !b; j = Next_hash(j, Size,
			++i))

			// i != Size&&!b - пока счётчик колизий не достигнет размера хэш-таблицы и пока 
			
			// j = Next_hash(j, Size, ++i) - при колизиях увеличиваем счётчик и 
			
			if (Data[j] == NULL || Data[j] == DEL)
				// если расчитанная позиция всегдабыла свободна или элемент, который на ней 
				
			{
			Data[j] = d;
	// записываем в рассчитанную позицию вставляемый Э-т, то есть структуру, 
	
	N++; // увеличиваем счётчик Э-ов
	b = true;// признак выхода из цикла, то есть Э-т уже вставлен
			}
	return b;
}
//int Object::SearchInd(int key) // функция поиска позиции Э-а (структуры) по ключу в хэш-таблице
//{
//	int t = -1;// номер найденного Э-а, если ничего не нашли, то возвращает функция -1
//	bool b = false;// признак найден Э-т или нет
//	if (N != 0) // если в таблице уже есть Э-ты, то есть текущее к-во Э-в!=0 
//		for (int i = 0, j = HashFunction(key, Size, 0); Data[j] != NULL && i != Size * Size && !b; j =
//			HashFunction(key, Size, ++i))
//			// i - счётчик колизий, j - позиция для поиска искомого Э-а, расчитываем по хэш-
//
//			if (Data[j] != DEL) // если на текущей позиции не удалён Э-т
//				if (GetKey(Data[j]) == key)
//					// сравниваем ключ эл-та на тек. позиции с искомым ключом
//				{
//					// если совпадают ключи, то запоминаем позицию заданного эл-та 
//					t = j; // номер найденного эл-та
//					b = true; // -1 , если эл-т не найден
//				}
//	return t; // возвращ. позицию найденного эл-та
//}
int Object::SearchInd(int hash) {
	int t = -1; // Номер найденного элемента
	bool b = false; // Признак найденного элемента

	if (N != 0) {
		for (int i = 0; i < Size * Size && !b; ++i) {
			int j = HashFunction(hash, Size, i); // Вычисляем позицию по хеш-функции
			if (Data[j] != NULL && Data[j] != DEL) {
				int h = HashFunction(GetKey(Data[j]), Size, 0); // Получаем хеш-номер текущего элемента
				if (h == hash) {
					t = j; // Запоминаем позицию найденного элемента
					b = true; // Устанавливаем флаг найденного элемента
				}
			}
		}
	}

	if (t >= 0) {
		std::cout << "Элемент с хеш-номером " << hash << " найден в позиции " << t << std::endl;
	}
	else {
		std::cout << "Элемент с хеш-номером " << hash << " не найден" << std::endl;
	}

	return t; // Возвращаем позицию найденного элемента или -1, если элемент не найден
}


void* Object::Search(int key) // функция поиска Э-та по ключу
{
	int t = SearchInd(key);
	// вызываем функцию поиска позиции по ключу и записываем в перемнную t эту позицию
	return (t >= 0) ? (Data[t]) : (NULL);
	// если эл-т найден (t >= 0), возвращаем хранящиеся в нем данные, иначе возвращ. 0
}

void* Object::Delete(int key) // функция удаления по ключу, которая возвращает У-ль на данные, У-ль на которые 

{
int i = SearchInd(key);
// вызываем функцию поиска позиции по ключу и записываем в перемнную t эту позицию
void* t = Data[i]; // У-ль на данные в стороке хэш-таблицы с найденной позицией
if (t != NULL) // если данные есть
{
Data[i] = DEL; // в качестве нового значения указателя записываем -1, то есть показываем, что Э-

N--; // уменьшам кол-во текущих Э-в
}
return t;
}

bool Object::Delete(void* d) // функция удаления Э-а по данным
{
	// 1. получаем ключ по переданным данным: (GetKey(d)
	// 2. вызываемфункцию удаления по найденному ключу
	// 3. возвращаем сравнение результата фунции удаления с NULLом
	return (Delete(GetKey(d)) != NULL);
}

void Object::Scan(void(*f)(void*))
// функция вывода хэш-таблицы, которая принимает функцию для вывода одного Э-а
// а та в свою очередь принимает в качестве аргумента У-ль на произвольные данные
{
	for (int i = 0; i < this->Size; i++) // цикл для вывода хэш-таблицы построчно
	{
		std::cout << " Элемент " << i << ": ";
		if ((this->Data)[i] == NULL)
			std::cout << " пусто" << std::endl;
		else if ((this->Data)[i] == DEL)

			std::cout << " удален" << std::endl;
		else f((this->Data)[i]);
	}
}